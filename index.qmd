---
title: "Levin Lab"
format:
  html:
    toc: false
    anchor-sections: false
    embed-resources: true
    theme: none
    css: styles.css
    include-in-header:
      - text: |
          <meta name="description" content="Cardiovascular genetics research at the University of Pennsylvania">
validate-yaml: false
bibliography: manuscripts-recent.bib
csl: "templates/american-medical-association-no-et-al-v2.csl"
nocite: '@*'
# filters:
#   - lua/recent-publications.lua
params:
  n_recent: 5
  zotero_user_id: !expr Sys.getenv("ZOTERO_USER_ID", "")
  zotero_api_key: !expr Sys.getenv("ZOTERO_API_KEY", "")
  zotero_collection_key: !expr Sys.getenv("ZOTERO_COLLECTION_KEY", "")
---

```{r setup, include = FALSE}
library(tidyverse)
library(glue)
library(googlesheets4)
library(zoterro)

# Validate Zotero configuration
validate_zotero_config <- function() {
  user_id <- params$zotero_user_id
  api_key <- params$zotero_api_key
  collection_key <- params$zotero_collection_key
  
  if (is.na(user_id) || user_id == "") {
    stop("ZOTERO_USER_ID environment variable is not set or empty")
  }
  
  if (is.na(api_key) || api_key == "") {
    stop("ZOTERO_API_KEY environment variable is not set or empty")
  }
  
  if (is.na(collection_key) || collection_key == "") {
    stop("ZOTERO_COLLECTION_KEY environment variable is not set or empty")
  }
  
  cat("✅ Zotero configuration validated\n")
  cat("   User ID: ***", substr(user_id, nchar(user_id)-3, nchar(user_id)), "\n")
  cat("   API Key: ***", substr(api_key, nchar(api_key)-3, nchar(api_key)), "\n")
  cat("   Collection: ***", substr(collection_key, nchar(collection_key)-3, nchar(collection_key)), "\n")
  
  return(list(
    user_id = user_id,
    api_key = api_key,
    collection_key = collection_key
  ))
}

# Validate configuration at startup
zotero_config <- validate_zotero_config()

# Define temporary file paths
temp_files <- c("manuscripts.bib")

# Function to ensure directory exists
ensure_dir <- function(path) {
  if (!dir.exists(dirname(path))) {
    dir.create(dirname(path), recursive = TRUE)
  }
}

# Function to cleanup temporary files
cleanup_temp_files <- function() {
  for (file in temp_files) {
    if (file.exists(file)) {
      file.remove(file)
      cat("Cleaned up:", file, "\n")
    }
  }
}

# Function to fetch and save bibliography from Zotero
fetch_zotero_bibliography <- function(collection_key, user_id, api_key, tags, filename) {
  tryCatch({
    cat("Fetching", filename, "from Zotero...\n")
    
    # Build query based on tags
    query_list <- list(
      itemType = "-attachment",
      format = "bibtex"
    )
    
    # Add tag filter if provided
    if (!is.null(tags) && tags != "") {
      query_list$tag <- tags
    }
    
    # Fetch items from Zotero
    bib_data <- zoterro::items(
      collection_key = collection_key,
      user = zoterro::zotero_user_id(user_id),
      api_key = api_key,
      as_tibble = FALSE,
      query = query_list
    )
    
    # Ensure directory exists
    ensure_dir(filename)
    
    # Write to file
    writeLines(rawToChar(bib_data), filename)
    cat("Successfully saved", filename, "\n")
    
    return(TRUE)
  }, error = function(e) {
    cat("Error fetching", filename, ":", e$message, "\n")
    return(FALSE)
  })
}

# Pre-render: Fetch all bibliographies from Zotero
cat("=== Fetching bibliographies from Zotero ===\n")

# Use validated configuration
user_id <- zotero_config$user_id
api_key <- zotero_config$api_key
collection_key <- zotero_config$collection_key

# Define bibliography configurations
bib_configs <- list(
  manuscripts = list(
    tags = "-Abstract || Preprint-final-published",
    file = "manuscripts.bib"
  )
)

# Fetch each bibliography
bib_success <- map_lgl(bib_configs, function(config) {
  fetch_zotero_bibliography(
    collection_key = collection_key,
    user_id = user_id,
    api_key = api_key,
    tags = config$tags,
    filename = config$file
  )
})

# Check if all bibliographies were fetched successfully
if (!all(bib_success)) {
  stop("Failed to fetch one or more bibliographies from Zotero")
}

cat("=== All bibliographies fetched successfully ===\n")

```


```{r, include = FALSE}
# Simple function to clean bibtex note fields
clean_bibtex_authorship_notes <- function(bib_file_path) {
  
  # Step 1: Read the bibtex file
  bib_content <- readLines(bib_file_path, warn = FALSE)
  
  cleaned_lines <- c()
  i <- 1
  
  while (i <= length(bib_content)) {
    line <- bib_content[i]
    
    # Step 2: Check if line starts with "note = {"
    if (grepl("^\\s*note\\s*=\\s*\\{", line)) {
      # cat("DEBUG: Found note field at line", i, "\n")
      
      # Step 3: Extract everything between opening and closing braces
      note_text <- ""
      
      # Get the part after the opening brace from the first line
      first_part <- sub("^\\s*note\\s*=\\s*\\{(.*)$", "\\1", line)
      note_text <- first_part
      
      # Continue reading lines until we find the closing brace
      while (!grepl("\\}", note_text) && i < length(bib_content)) {
        i <- i + 1
        note_text <- paste(note_text, bib_content[i], sep = "\n")
      }
      
      # Remove the closing brace and comma
      note_text <- sub("\\}\\s*,?\\s*$", "", note_text)
      
      # cat("DEBUG: Extracted note text:", note_text, "\n")
      
      # Step 4: Split by newline
      note_lines <- strsplit(note_text, "\n", fixed = TRUE)[[1]]
      
      # Step 5: Keep lines starting with "Authorship Note:"
      authorship_lines <- note_lines[grepl("^\\s*Authorship Note:", note_lines)]
      
      # cat("DEBUG: Found", length(authorship_lines), "authorship lines\n")
      
      # Step 6: If we have authorship lines, insert them back
      if (length(authorship_lines) > 0) {
        # Clean up the authorship line (remove "Authorship Note:" prefix)
        # authorship_content <- sub("^\\s*Authorship Note:\\s*", "", authorship_lines[1])
        authorship_content <- trimws(authorship_lines[1])
        
        # cat("DEBUG: Final authorship content:", authorship_content, "\n")
        
        # Insert the cleaned note field
        cleaned_lines <- c(cleaned_lines, paste0("\tnote = {", authorship_content, "},"))
      }
      # If no authorship lines found, skip the note field entirely
      
    } else {
      # Not a note field, keep the line as-is
      cleaned_lines <- c(cleaned_lines, line)
    }
    
    i <- i + 1
  }
  
  return(cleaned_lines)
}

# Function to process and save cleaned bibtex file
process_bibtex_file <- function(input_file, output_file = NULL) {
  if (is.null(output_file)) {
    output_file <- input_file  # Overwrite the original file
  }
  
  cat("Cleaning authorship notes in:", input_file, "\n")
  
  cleaned_content <- clean_bibtex_authorship_notes(input_file)
  
  # Write the cleaned content back to file
  writeLines(cleaned_content, output_file)
  
  cat("Cleaned bibtex saved to:", output_file, "\n")
  
  return(output_file)
}

# Example usage function to clean all bibliography files
clean_all_bibliography_files <- function() {
  # List of your bibliography files
  bib_files <- c("manuscripts.bib")
  
  for (bib_file in bib_files) {
    if (file.exists(bib_file)) {
      process_bibtex_file(bib_file)
    } else {
      cat("Warning: File not found:", bib_file, "\n")
    }
  }
}

clean_all_bibliography_files()
```

```{r create-recent-bib, include = FALSE}
# Create a filtered bibliography with only the N most recent publications
create_recent_bibliography <- function(input_bib, output_bib, n_recent = 5) {
  cat("Creating recent publications bibliography...\n")
  
  # Month name to number mapping
  month_map <- c(
    jan = 1, january = 1,
    feb = 2, february = 2,
    mar = 3, march = 3,
    apr = 4, april = 4,
    may = 5,
    jun = 6, june = 6,
    jul = 7, july = 7,
    aug = 8, august = 8,
    sep = 9, september = 9,
    oct = 10, october = 10,
    nov = 11, november = 11,
    dec = 12, december = 12
  )
  
  # Read the bib file
  bib_content <- readLines(input_bib, warn = FALSE)
  
  # Parse entries
  entries <- list()
  current_entry <- NULL
  current_lines <- c()
  current_year <- NULL
  current_month <- NULL
  
  for (line in bib_content) {
    # Check for entry start
    if (grepl("^@", line)) {
      # Save previous entry if exists
      if (!is.null(current_entry) && !is.null(current_year)) {
        entries[[length(entries) + 1]] <- list(
          key = current_entry,
          year = current_year,
          month = ifelse(is.null(current_month), 0, current_month),
          lines = current_lines
        )
      }
      # Start new entry
      key_match <- regmatches(line, regexec("@\\w+\\{([^,]+)", line))[[1]]
      if (length(key_match) > 1) {
        current_entry <- key_match[2]
        current_lines <- c(line)
        current_year <- NULL
        current_month <- NULL
      }
    } else if (!is.null(current_entry)) {
      # Add line to current entry
      current_lines <- c(current_lines, line)
      
      # Check for year
      if (is.null(current_year)) {
        year_match <- regmatches(line, regexec("year\\s*=\\s*[{]?(\\d{4})[}]?", line))[[1]]
        if (length(year_match) > 1) {
          current_year <- as.numeric(year_match[2])
        }
      }
      
      # Check for month
      if (is.null(current_month)) {
        month_match <- regmatches(line, regexec("month\\s*=\\s*[{]?([^,}]+)[}]?", line))[[1]]
        if (length(month_match) > 1) {
          month_str <- tolower(trimws(month_match[2]))
          # Try to convert month string to number
          if (month_str %in% names(month_map)) {
            current_month <- month_map[[month_str]]
          } else if (grepl("^\\d+$", month_str)) {
            current_month <- as.numeric(month_str)
          }
        }
      }
    }
  }
  
  # Don't forget the last entry
  if (!is.null(current_entry) && !is.null(current_year)) {
    entries[[length(entries) + 1]] <- list(
      key = current_entry,
      year = current_year,
      month = ifelse(is.null(current_month), 0, current_month),
      lines = current_lines
    )
  }
  
  cat("  Found", length(entries), "total entries\n")
  
  # Sort by year (descending), then by month (descending)
  entries <- entries[order(
    sapply(entries, function(x) x$year),
    sapply(entries, function(x) x$month),
    decreasing = TRUE
  )]
  
  # Take only the N most recent
  recent_entries <- head(entries, n_recent)
  
  cat("  Keeping", length(recent_entries), "most recent entries:\n")
  for (entry in recent_entries) {
    month_name <- ifelse(entry$month > 0, 
                         names(month_map)[match(entry$month, month_map)][1],
                         "unknown")
    cat("    -", entry$key, "(", month_name, entry$year, ")\n")
  }
  
  # Write the filtered bibliography
  all_lines <- unlist(lapply(recent_entries, function(x) x$lines))
  writeLines(all_lines, output_bib)
  
  cat("✅ Created", output_bib, "\n")
}

# Create the recent publications bib file
create_recent_bibliography("manuscripts.bib", "manuscripts-recent.bib", n_recent = params$n_recent)
```
::: {.content}

## Cardiovascular genetics research at the University of Pennsylvania

We study the genetic basis of cardiovascular disease using large-scale biobanks and electronic health records.

Our research focuses on characterizing how common and rare germline genetic variation shapes susceptibility to cardiovascular risk. We translate these findings into clinical applications for personalized prevention and treatment.

We work with the [Million Veteran Program](https://www.mvp.va.gov/pwa/), [Penn Medicine Biobank](https://pmbb.med.upenn.edu/), and other population-scale cohorts using a range of computational, genetic, epidemiologic, and clinical/translational methods.

## Recent Publications

::: {#refs style="font-size: 0.9em; text-align: justify; padding-left: 30px; padding-right: 30px;"}
:::

[View all publications →](publications.html)

<br>[Contact](mailto:Michael.Levin@pennmedicine.upenn.edu) | [GitHub](https://github.com/mglev1n)

---

*Last updated: `{r} format(Sys.Date(), "%B %d, %Y")`*

:::
